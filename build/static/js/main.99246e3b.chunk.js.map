{"version":3,"sources":["index.js"],"names":["bsv","require","axios","hashwrap","txid","options","Error","length","test","wocNet","network","get","rawTx","data","proof","txOrId","hash","target","merkleRoot","targetType","nodes","branches","map","x","index","parseInt","reduce","a","e","pos","provider","headers","apiKey","taalApiKey","startsWith","Authorization","mapiResponse","payloadHash","crypto","Hash","sha256","Buffer","from","payload","signature","Signature","fromString","publicKey","PublicKey","ECDSA","verify","JSON","parse","returnResult","resultDescription","inputs","tx","Transaction","input","prevTxId","toString","mapiResponses","module","exports"],"mappings":"iKAAMA,EAAMC,EAAQ,KACdC,EAAQD,EAAQ,KAmChBE,EAAQ,iDAAG,WAAOC,GAAP,wIAAaC,EAAb,+BAAuB,CAAC,EAClCD,EADU,sBAEP,IAAIE,MAAM,mBAFH,UAIK,KAAhBF,EAAKG,QAAkB,gBAAgBC,KAAKJ,GAJjC,sBAKP,IAAIE,MAAM,gBALH,cAOTG,EAA6B,YAApBJ,EAAQK,QAAwB,OAAS,OAPzC,SAQeR,EAAMS,IAAN,8CACWF,EADX,eACwBL,EADxB,SARf,mBAQDQ,EARC,EAQPC,KARO,uBAYP,IAAIP,MAAJ,sDAAyDF,IAZlD,yBAceF,EAAMS,IAAN,8CACWF,EADX,eACwBL,EADxB,WAdf,sBAcDU,EAdC,EAcPD,MAdO,0CAkBN,CACLD,QACAE,MAAO,CACLC,OAAQD,EAAM,GAAGE,KACjBC,OAAQH,EAAM,GAAGI,WACjBC,WAAY,aACZC,MAAON,EAAM,GAAGO,SAASC,KAAI,SAAAC,GAAC,OAAIA,EAAEP,IAAN,IAC9BQ,MAAOC,SAASX,EAAM,GAAGO,SAASK,QAChC,SAACC,EAAGC,GAAJ,OAAgBD,GAAe,MAAVC,EAAEC,IAAc,IAAM,IAA3C,GAAkD,IACjD,MA3BM,WA+BTC,EAAW,sBACXC,EAAU,CAAC,EACTC,EAAS3B,EAAQ4B,WAEC,YAApB5B,EAAQK,QAnCC,oBAoCNsB,EApCM,uBAqCH,IAAI1B,MAAM,qCArCP,WAuCN0B,EAAOE,WAAW,YAvCZ,uBAwCH,IAAI5B,MAAM,kDAxCP,eA4CT0B,IACFF,EAAW,gBACXC,EAAU,CAAEA,QAAS,CAAEI,cAAeH,KA9C3B,UAiDwB9B,EAAMS,IAAN,kBACxBmB,EADwB,oBACJ1B,GAAQ2B,GAlD5B,oBAiDCK,EAjDD,EAiDLvB,KAGFwB,EAAcrC,EAAIsC,OAAOC,KAAKC,OAClCC,EAAOC,KAAKN,EAAaO,UAErBC,EAAY5C,EAAIsC,OAAOO,UAAUC,WAAWV,EAAaQ,WACzDG,EAAY/C,EAAIgD,UAAUF,WAAWV,EAAaW,YACW,IAA/D/C,EAAIsC,OAAOW,MAAMC,OAAOb,EAAaO,EAAWG,GAzDvC,uBA0DL,IAAIzC,MAAJ,0CAC+BF,EAD/B,sBACiDgC,EAAaO,QAD9D,wBACqFP,EAAaW,UADlG,wBAC2HX,EAAaQ,YA3DnI,YA8DPD,EAAUQ,KAAKC,MAAMhB,EAAaO,UAC5BvC,OAASA,EA/DR,uBAgEL,IAAIE,MAAJ,8DACmDF,EADnD,4BAC2EuC,EAAQvC,KADnF,aAhEK,WAoEgB,YAAzBuC,EAAQU,aApEC,uBAqEL,IAAI/C,MAAJ,iDAAoDF,EAApD,2BAA2EuC,EAAQU,aAAnF,gCAAuHV,EAAQW,oBArE1H,QAuEPC,EAAS,CAAC,EACVC,EAAK,IAAIxD,EAAIyD,YAAY7C,GAxElB,cAyEO4C,EAAGD,QAzEV,8DAyEFG,EAzEE,QA0ELtD,EAAOsD,EAAMC,SAASC,SAAS,QACjCL,EAAOnD,GA3EA,yEA4EUD,EAASC,EAAMC,GA5EzB,QA4EXkD,EAAOnD,GA5EI,iLA8EN,CACLQ,QACAiD,cAAe,CAACzB,GAChBmB,WAjFW,iEAAH,sDAsFdO,EAAOC,QAAU5D,C","file":"static/js/main.99246e3b.chunk.js","sourcesContent":["const bsv = require('bsv')\nconst axios = require('axios')\n\n/**\n * Returns an SPV envelope given the TXID of the target transaction.\n *\n * The returned object for mined transactions looks like:\n * ```\n * rawTx\n * proof: {\n *   txOrId: transaction hash\n *   target: merkle root\n *   targetType: 'merkleRoot'\n *   nodes: array of merkle tree hashes\n *   index: integer binary encoding of left (1) or right (0) path through the merkle tree\n * }\n * ```\n *\n * The returned object for pending transactions looks like:\n * ```\n * rawTx\n * mapiResponses: array of single mapi response for this transaction id\n * inputs: an object where keys are transaction ids that contributed inputs to this transaction and value is recursive hashwrap of those txids.\n * ```\n *\n * Uses api.whatsonchain.com to lookup raw transaction and merkle proofs.\n *\n * For pending transactions (without merkle proofs):\n * Use the taalApiKey property on the options parameter object to use TAAL's mAPI.\n * Otherwise mapi.gorillapool.io is used.\n *\n * @param {String} txid The confirmed or unconformed TXID for which you would like to generate an SPV envelope.\n * @param {Object} options Optional. Provide a TAAL api key with { taalApiKey: 'mainnet_9596de07e92300c6287e43...' }. Provide { network: 'testnet' or 'mainnet' }. If testnet, a testnet TAAL key is required\n *\n * @returns {Object} The SPV envelope associated with the TXID you provided.\n */\nconst hashwrap = async (txid, options = {}) => {\n  if (!txid) {\n    throw new Error('TXID is missing')\n  }\n  if (txid.length !== 64 || !/[0-9a-f]{64}/g.test(txid)) {\n    throw new Error('Invalid TXID')\n  }\n  const wocNet = options.network === 'testnet' ? 'test' : 'main'\n  const { data: rawTx } = await axios.get(\n    `https://api.whatsonchain.com/v1/bsv/${wocNet}/tx/${txid}/hex`\n  )\n  if (!rawTx) {\n    throw new Error(`Could not find transaction on WhatsOnChain: ${txid}`)\n  }\n  const { data: proof } = await axios.get(\n    `https://api.whatsonchain.com/v1/bsv/${wocNet}/tx/${txid}/proof`\n  )\n  if (proof) {\n    return {\n      rawTx,\n      proof: {\n        txOrId: proof[0].hash,\n        target: proof[0].merkleRoot,\n        targetType: 'merkleRoot',\n        nodes: proof[0].branches.map(x => x.hash),\n        index: parseInt(proof[0].branches.reduce(\n          (a, e) => ('' + a + (e.pos === 'R' ? '0' : '1')), ''\n        ), 2)\n      }\n    }\n  } else {\n    let provider = 'mapi.gorillapool.io'\n    let headers = {}\n    const apiKey = options.taalApiKey\n\n    if (options.network === 'testnet') {\n      if (!apiKey) {\n        throw new Error('Taal API key required in testnet!')\n      }\n      if (!apiKey.startsWith('testnet_')) {\n        throw new Error('Taal API key must be a testnet key for testnet')\n      }\n    }\n\n    if (apiKey) {\n      provider = 'mapi.taal.com'\n      headers = { headers: { Authorization: apiKey } }\n    }\n\n    const { data: mapiResponse } = await axios.get(\n      `https://${provider}/mapi/tx/${txid}`, headers\n    )\n    const payloadHash = bsv.crypto.Hash.sha256(\n      Buffer.from(mapiResponse.payload)\n    )\n    const signature = bsv.crypto.Signature.fromString(mapiResponse.signature)\n    const publicKey = bsv.PublicKey.fromString(mapiResponse.publicKey)\n    if (bsv.crypto.ECDSA.verify(payloadHash, signature, publicKey) !== true) {\n      throw new Error(\n        `Inalid mAPI signature for TXID: ${txid}, payload: ${mapiResponse.payload}, publicKey: ${mapiResponse.publicKey}, signature: ${mapiResponse.signature}`\n      )\n    }\n    const payload = JSON.parse(mapiResponse.payload)\n    if (payload.txid !== txid) {\n      throw new Error(\n        `Invalid mAPI response, expected a response for TXID ${txid} but got one for ${payload.txid} instead`\n      )\n    }\n    if (payload.returnResult !== 'success') {\n      throw new Error(`Invalid mAPI status response for TXID: ${txid}, returnResult: ${payload.returnResult}, resultDescription: ${payload.resultDescription}`)\n    }\n    const inputs = {}\n    const tx = new bsv.Transaction(rawTx)\n    for (const input of tx.inputs) {\n      const txid = input.prevTxId.toString('hex')\n      if (inputs[txid]) continue\n      inputs[txid] = await hashwrap(txid, options)\n    }\n    return {\n      rawTx,\n      mapiResponses: [mapiResponse],\n      inputs\n    }\n  }\n}\n\nmodule.exports = hashwrap\n"],"sourceRoot":""}